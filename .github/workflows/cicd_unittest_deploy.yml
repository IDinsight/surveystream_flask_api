# Create GitHub Action to run unit tests inside a Docker container
name: Run Unit Tests and Deploy

on:
  push:
    branches:
      - dev
      - staging
      - production

  pull_request:
    branches:
      - "*"

jobs:
  UnitTest:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Load .env file
        uses: xom9ikk/dotenv@v2.2.0
        with:
          path: ./.github/workflows
          mode: variables

      - name: Build the Docker image
        run: docker build -f Dockerfile.api --rm --build-arg NAME=${{ env.BACKEND_NAME }} --build-arg PORT=${{ env.BACKEND_PORT }} --platform=linux/amd64 -t ${{ env.BACKEND_NAME }}:${{ env.VERSION }} .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: "arn:aws:iam::${{ env.DEV_ACCOUNT }}:role/github-actions-role-flask-unittest"
          role-session-name: testingrolesession
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure output directory
        run: |
          mkdir -p /tmp/coverage
          sudo chmod 777 /tmp/coverage

      - name: Check DB Migration
        run: docker compose -f docker-compose/docker-compose.db-check.yml -f docker-compose/docker-compose.override-unit-test.yml run --rm api ;

      - name: Run unit tests
        run: docker compose -f docker-compose/docker-compose.unit-test.yml -f docker-compose/docker-compose.override-unit-test.yml run --rm api ;

      - name: Send coverage report to Coveralls
        uses: coverallsapp/github-action@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          file: /tmp/coverage/coverage.lcov

  UpdateDevDB:
    if: github.event_name == 'push' &&  github.ref == 'refs/heads/dev'
    name: Update Dev DB
    runs-on: ubuntu-latest
    needs: UnitTest

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Load .env file
        uses: xom9ikk/dotenv@v2.2.0
        with:
          path: ./.github/workflows
          mode: variables
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: "arn:aws:iam::${{ env.DEV_ACCOUNT }}:role/github-actions-role-flask-unittest"
          role-session-name: testingrolesession
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: web-callisto-ecr-repository
          IMAGE_TAG: PreMigration

        run: |
          docker build -f Dockerfile.api --rm --build-arg NAME=${{ env.BACKEND_NAME }} --build-arg PORT=${{ env.BACKEND_PORT }} --platform=linux/amd64 -t ${{ env.BACKEND_NAME }}:${{ env.VERSION }} .
          docker tag ${{ env.BACKEND_NAME }}:${{ env.VERSION }} $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Task definition download
        id: download-task-def
        env:
          ecs_task_def_name: update-db
        run: |
          aws ecs describe-task-definition --task-definition "$ecs_task_def_name" --query taskDefinition > task-definition.json
      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: api
          image: ${{ steps.build-image.outputs.image }}
      - name: Update Dev Db
        id: update-dev-db
        shell: bash
        env:
          CONTAINER_NAME: api
        run: |
          TASK_ID=$(aws ecs run-task --cluster surveystream-ecs-cluster --launch-type FARGATE --task-definition update-db --network-configuration "awsvpcConfiguration={subnets=[subnet-0d2bc255f8695dbb2,subnet-0ea110bb20ce8e7a7],securityGroups=[sg-063bd5346765c1b9f]}" --region ${{ env.AWS_REGION }} --query tasks[0].taskArn --output text )

          echo "Waiting for task to complete..."

          WAIT=$(aws ecs wait tasks-stopped --cluster surveystream-ecs-cluster --tasks $TASK_ID --region ${{ env.AWS_REGION }})

          EXIT_CODE=$(aws ecs describe-tasks --cluster surveystream-ecs-cluster --tasks $TASK_ID --region ${{ env.AWS_REGION }} --query tasks[0].containers[0].exitCode --output text  )
          echo "Exit code: $EXIT_CODE"
          if [ $EXIT_CODE -eq 0 ]; then\
            echo "DB is up to date";\
            exit 0;\
          else\
            echo "DB is not up to date";\
            exit 1;\
          fi
      - name: Build, tag, and push image to Amazon ECR
        id: build-post-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: web-callisto-ecr-repository
          IMAGE_TAG: PostMigration

        run: |
          docker build -f Dockerfile.api --rm --build-arg NAME=${{ env.BACKEND_NAME }} --build-arg PORT=${{ env.BACKEND_PORT }} --platform=linux/amd64 -t ${{ env.BACKEND_NAME }}:${{ env.VERSION }} .
          docker tag ${{ env.BACKEND_NAME }}:${{ env.VERSION }} $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  Deploy-Staging:
    if: github.event_name == 'push' &&  github.ref == 'refs/heads/staging'
    name: Deploy Callisto Staging
    runs-on: ubuntu-latest
    needs: UnitTest

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4
      - name: Load .env file
        uses: xom9ikk/dotenv@v2.2.0
        with:
          path: ./.github/workflows
          mode: variables

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: "arn:aws:iam::${{ env.STAGING_ACCOUNT }}:role/github-actions-role-backend"
          role-session-name: stagingrolesession
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: web-callisto-ecr-repository
          IMAGE_TAG: backend

        run: |
          docker build -f Dockerfile.api --rm --build-arg NAME=${{ env.BACKEND_NAME }} --build-arg PORT=${{ env.BACKEND_PORT }} --platform=linux/amd64 -t ${{ env.BACKEND_NAME }}:${{ env.VERSION }} .
          docker tag ${{ env.BACKEND_NAME }}:${{ env.VERSION }} $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Task definition download
        id: download-task-def
        env:
          ecs_task_def_name: backend-task
        run: |
          aws ecs describe-task-definition --task-definition "$ecs_task_def_name" --query taskDefinition > task-definition.json

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: api
          image: ${{ steps.build-image.outputs.image }}

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        timeout-minutes: 3
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: backend
          cluster: web-callisto-cluster
          wait-for-service-stability: true
      # We need to wait for the application to start we can check if it was successful. The value of 1 minute is arbitrary and can be changed
      - name: Wait for Application to start
        id: deployment-complete
        run: sleep 1m
        shell: bash

      - name: Check if deployment was successful
        id: check-deployment
        run: |
          RUNNING_TASKS=$(aws ecs describe-services --cluster web-callisto-cluster --services backend --query services[0].deployments[0].runningCount | jq -r ".")
              
          if [ "$RUNNING_TASKS" -eq "0" ]; then
            echo "Deployment failed."
            exit 1
          fi

  Deploy-Production:
    if: github.event_name == 'push' &&  github.ref == 'refs/heads/production'
    name: Deploy Callisto Production
    runs-on: ubuntu-latest
    needs: UnitTest

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4
      - name: Load .env file
        uses: xom9ikk/dotenv@v2.2.0
        with:
          path: ./.github/workflows
          mode: variables

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: "arn:aws:iam::${{ env.PROD_ACCOUNT }}:role/github-actions-role-backend"
          role-session-name: prodrolesession
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: web-callisto-ecr-repository
          IMAGE_TAG: backend

        run: |
          docker build -f Dockerfile.api --rm --build-arg NAME=${{ env.BACKEND_NAME }} --build-arg PORT=${{ env.BACKEND_PORT }} --platform=linux/amd64 -t ${{ env.BACKEND_NAME }}:${{ env.VERSION }} . 
          docker tag ${{ env.BACKEND_NAME }}:${{ env.VERSION }} $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Task definition download
        id: download-task-def
        env:
          ecs_task_def_name: backend-task
        run: |
          aws ecs describe-task-definition --task-definition "$ecs_task_def_name" --query taskDefinition > task-definition.json

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: api
          image: ${{ steps.build-image.outputs.image }}

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        timeout-minutes: 3
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: backend
          cluster: web-callisto-cluster
          wait-for-service-stability: true
      # We need to wait for the application to start we can check if it was successful. The value of 1 minute is arbitrary and can be changed
      - name: Wait for Application to start
        id: deployment-complete
        run: sleep 1m
        shell: bash

      - name: Check if deployment was successful
        id: check-deployment
        run: |
          RUNNING_TASKS=$(aws ecs describe-services --cluster web-callisto-cluster --services backend --query services[0].deployments[0].runningCount | jq -r ".")
              
          if [ "$RUNNING_TASKS" -eq "0" ]; then
            echo "Deployment failed."
            exit 1
          fi
