# Create GitHub Action to run unit tests inside a Docker container
name: Run Unit Tests and Deploy

on:
  push:
    branches:
      - dev
      - staging
      - production

  pull_request:
    branches:
      - "*"

jobs:
  files-changed:
    name: Detect what files changed
    runs-on: ubuntu-latest
    timeout-minutes: 3

    # Map a step output to a job output
    outputs:
      common: ${{ steps.changes.outputs.common }}
      assignments: ${{ steps.changes.outputs.assignments }}
      auth: ${{ steps.changes.outputs.auth }}
      docs: ${{ steps.changes.outputs.docs }}
      dq: ${{ steps.changes.outputs.dq }}
      emails: ${{ steps.changes.outputs.emails }}
      enumerators: ${{ steps.changes.outputs.enumerators }}
      forms: ${{ steps.changes.outputs.forms }}
      healthcheck: ${{ steps.changes.outputs.healthcheck }}
      locations: ${{ steps.changes.outputs.locations }}
      mapping: ${{ steps.changes.outputs.mapping }}
      media_files: ${{ steps.changes.outputs.media_files }}
      module_questionnaire: ${{ steps.changes.outputs.module_questionnaire }}
      module_selection: ${{ steps.changes.outputs.module_selection }}
      notifications: ${{ steps.changes.outputs.notifications }}
      profile: ${{ steps.changes.outputs.profile }}
      roles: ${{ steps.changes.outputs.roles }}
      surveys: ${{ steps.changes.outputs.surveys }}
      target_status_mapping: ${{ steps.changes.outputs.target_status_mapping }}
      targets: ${{ steps.changes.outputs.targets }}
      timezones: ${{ steps.changes.outputs.timezones }}
      user_management: ${{ steps.changes.outputs.user_management }}

    steps:
      - uses: actions/checkout@v4

      - name: Check for file changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          token: ${{ github.token }}
          filters: |
            # Tag changes to shared app utilities as common
            common:
              - 'app/utils/**'

            # One filter per blueprint folder under app/blueprints
            assignments:
              - 'app/blueprints/assignments/**'
            auth:
              - 'app/blueprints/auth/**'
            docs:
              - 'app/blueprints/docs/**'
            dq:
              - 'app/blueprints/dq/**'
            emails:
              - 'app/blueprints/emails/**'
            enumerators:
              - 'app/blueprints/enumerators/**'
            forms:
              - 'app/blueprints/forms/**'
            healthcheck:
              - 'app/blueprints/healthcheck/**'
            locations:
              - 'app/blueprints/locations/**'
            mapping:
              - 'app/blueprints/mapping/**'
            media_files:
              - 'app/blueprints/media_files/**'
            module_questionnaire:
              - 'app/blueprints/module_questionnaire/**'
            module_selection:
              - 'app/blueprints/module_selection/**'
            notifications:
              - 'app/blueprints/notifications/**'
            profile:
              - 'app/blueprints/profile/**'
            roles:
              - 'app/blueprints/roles/**'
            surveys:
              - 'app/blueprints/surveys/**'
            target_status_mapping:
              - 'app/blueprints/target_status_mapping/**'
            targets:
              - 'app/blueprints/targets/**'
            timezones:
              - 'app/blueprints/timezones/**'
            user_management:
              - 'app/blueprints/user_management/**'

  UnitTest:
    runs-on: ubuntu-latest
    needs: files-changed

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Load .env file
        uses: xom9ikk/dotenv@v2.2.0
        with:
          path: ./.github/workflows
          mode: variables

      - name: Build the Docker image
        run: docker build -f Dockerfile.api --rm --build-arg NAME=${{ env.BACKEND_NAME }} --build-arg PORT=${{ env.BACKEND_PORT }} --platform=linux/amd64 -t ${{ env.BACKEND_NAME }}:${{ env.VERSION }} .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: "arn:aws:iam::${{ env.DEV_ACCOUNT }}:role/github-actions-role-flask-unittest"
          role-session-name: testingrolesession
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure output directory
        run: |
          mkdir -p /tmp/coverage
          sudo chmod 777 /tmp/coverage

      - name: Check DB Migration
        run: docker compose -f docker-compose/docker-compose.db-check.yml -f docker-compose/docker-compose.override-unit-test.yml run --rm api ;

      - name: Select test files based on changes
        run: |
          if [ "${{ needs.files-changed.outputs.common }}" = 'true' ]; then
            TEST_PATHS=""
            echo "TEST_PATHS=" >> $GITHUB_ENV
          else
            TEST_PATHS=''
            [ "${{ needs.files-changed.outputs.assignments }}" = 'true' ] && [ -f tests/unit/test_assignments.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_assignments.py"
            [ "${{ needs.files-changed.outputs.auth }}" = 'true' ] && [ -f tests/unit/test_auth.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_auth.py"
            [ "${{ needs.files-changed.outputs.docs }}" = 'true' ] && [ -f tests/unit/test_docs.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_docs.py"
            [ "${{ needs.files-changed.outputs.dq }}" = 'true' ] && [ -f tests/unit/test_dq.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_dq.py"
            [ "${{ needs.files-changed.outputs.emails }}" = 'true' ] && [ -f tests/unit/test_emails.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_emails.py"
            [ "${{ needs.files-changed.outputs.enumerators }}" = 'true' ] && [ -f tests/unit/test_enumerators.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_enumerators.py"
            [ "${{ needs.files-changed.outputs.forms }}" = 'true' ] && [ -f tests/unit/test_forms.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_forms.py"
            [ "${{ needs.files-changed.outputs.healthcheck }}" = 'true' ] && [ -f tests/unit/test_healthcheck.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_healthcheck.py"
            [ "${{ needs.files-changed.outputs.locations }}" = 'true' ] && [ -f tests/unit/test_locations.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_locations.py"
            [ "${{ needs.files-changed.outputs.mapping }}" = 'true' ] && [ -f tests/unit/test_mapping.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_mapping.py"
            [ "${{ needs.files-changed.outputs.media_files }}" = 'true' ] && [ -f tests/unit/test_media_files.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_media_files.py"
            [ "${{ needs.files-changed.outputs.module_questionnaire }}" = 'true' ] && [ -f tests/unit/test_module_questionnaire.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_module_questionnaire.py"
            [ "${{ needs.files-changed.outputs.module_selection }}" = 'true' ] && [ -f tests/unit/test_module_selection.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_module_selection.py"
            [ "${{ needs.files-changed.outputs.notifications }}" = 'true' ] && [ -f tests/unit/test_notifications.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_notifications.py"
            [ "${{ needs.files-changed.outputs.profile }}" = 'true' ] && [ -f tests/unit/test_profile.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_profile.py"
            [ "${{ needs.files-changed.outputs.roles }}" = 'true' ] && [ -f tests/unit/test_roles.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_roles.py"
            [ "${{ needs.files-changed.outputs.surveys }}" = 'true' ] && [ -f tests/unit/test_surveys.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_surveys.py"
            [ "${{ needs.files-changed.outputs.target_status_mapping }}" = 'true' ] && [ -f tests/unit/test_target_status_mapping.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_target_status_mapping.py"
            [ "${{ needs.files-changed.outputs.targets }}" = 'true' ] && [ -f tests/unit/test_targets.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_targets.py"
            [ "${{ needs.files-changed.outputs.timezones }}" = 'true' ] && [ -f tests/unit/test_timezones.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_timezones.py"
            [ "${{ needs.files-changed.outputs.user_management }}" = 'true' ] && [ -f tests/unit/test_user_management.py ] && TEST_PATHS="$TEST_PATHS tests/unit/test_user_management.py"

            echo "TEST_PATHS=$(echo $TEST_PATHS)" >> $GITHUB_ENV
          fi
          echo "Tests according to file changes: ${TEST_PATHS}"

      - name: Run unit tests
        shell: bash
        run: |
          if [ -n "${TEST_PATHS}" ]; then
            echo "Running selected tests: ${TEST_PATHS}"
            docker compose -f docker-compose/docker-compose.unit-test.yml -f docker-compose/docker-compose.override-unit-test.yml run --rm api pytest -q ${TEST_PATHS}
          else
            echo "No targeted tests selected (or common changed). Running full test suite."
            docker compose -f docker-compose/docker-compose.unit-test.yml -f docker-compose/docker-compose.override-unit-test.yml run --rm api ;
          fi

      - name: Send coverage report to Coveralls
        uses: coverallsapp/github-action@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          file: /tmp/coverage/coverage.lcov

  UpdateDevDB:
    if: github.event_name == 'push' &&  github.ref == 'refs/heads/dev'
    name: Update Dev DB
    runs-on: ubuntu-latest
    needs: UnitTest

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Load .env file
        uses: xom9ikk/dotenv@v2.2.0
        with:
          path: ./.github/workflows
          mode: variables
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: "arn:aws:iam::${{ env.DEV_ACCOUNT }}:role/github-actions-role-flask-unittest"
          role-session-name: testingrolesession
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: web-callisto-ecr-repository
          IMAGE_TAG: PreMigration

        run: |
          docker build -f Dockerfile.api --rm --build-arg NAME=${{ env.BACKEND_NAME }} --build-arg PORT=${{ env.BACKEND_PORT }} --platform=linux/amd64 -t ${{ env.BACKEND_NAME }}:${{ env.VERSION }} .
          docker tag ${{ env.BACKEND_NAME }}:${{ env.VERSION }} $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Task definition download
        id: download-task-def
        env:
          ecs_task_def_name: update-db
        run: |
          aws ecs describe-task-definition --task-definition "$ecs_task_def_name" --query taskDefinition > task-definition.json
      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: api
          image: ${{ steps.build-image.outputs.image }}
      - name: Update Dev Db
        id: update-dev-db
        shell: bash
        env:
          CONTAINER_NAME: api
        run: |
          TASK_ID=$(aws ecs run-task --cluster surveystream-ecs-cluster --launch-type FARGATE --task-definition update-db --network-configuration "awsvpcConfiguration={subnets=[subnet-0d2bc255f8695dbb2,subnet-0ea110bb20ce8e7a7],securityGroups=[sg-063bd5346765c1b9f]}" --region ${{ env.AWS_REGION }} --query tasks[0].taskArn --output text )

          echo "Waiting for task to complete..."

          WAIT=$(aws ecs wait tasks-stopped --cluster surveystream-ecs-cluster --tasks $TASK_ID --region ${{ env.AWS_REGION }})

          EXIT_CODE=$(aws ecs describe-tasks --cluster surveystream-ecs-cluster --tasks $TASK_ID --region ${{ env.AWS_REGION }} --query tasks[0].containers[0].exitCode --output text  )
          echo "Exit code: $EXIT_CODE"
          if [ $EXIT_CODE -eq 0 ]; then\
            echo "DB is up to date";\
            exit 0;\
          else\
            echo "DB is not up to date";\
            exit 1;\
          fi
      - name: Build, tag, and push image to Amazon ECR
        id: build-post-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: web-callisto-ecr-repository
          IMAGE_TAG: PostMigration

        run: |
          docker build -f Dockerfile.api --rm --build-arg NAME=${{ env.BACKEND_NAME }} --build-arg PORT=${{ env.BACKEND_PORT }} --platform=linux/amd64 -t ${{ env.BACKEND_NAME }}:${{ env.VERSION }} .
          docker tag ${{ env.BACKEND_NAME }}:${{ env.VERSION }} $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  Deploy-Staging:
    if: github.event_name == 'push' &&  github.ref == 'refs/heads/staging'
    name: Deploy Callisto Staging
    runs-on: ubuntu-latest
    needs: UnitTest

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4
      - name: Load .env file
        uses: xom9ikk/dotenv@v2.2.0
        with:
          path: ./.github/workflows
          mode: variables

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: "arn:aws:iam::${{ env.STAGING_ACCOUNT }}:role/github-actions-role-backend"
          role-session-name: stagingrolesession
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: web-callisto-ecr-repository
          IMAGE_TAG: backend

        run: |
          docker build -f Dockerfile.api --rm --build-arg NAME=${{ env.BACKEND_NAME }} --build-arg PORT=${{ env.BACKEND_PORT }} --platform=linux/amd64 -t ${{ env.BACKEND_NAME }}:${{ env.VERSION }} .
          docker tag ${{ env.BACKEND_NAME }}:${{ env.VERSION }} $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Task definition download
        id: download-task-def
        env:
          ecs_task_def_name: backend-task
        run: |
          aws ecs describe-task-definition --task-definition "$ecs_task_def_name" --query taskDefinition > task-definition.json

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: api
          image: ${{ steps.build-image.outputs.image }}

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        timeout-minutes: 5
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: backend
          cluster: web-callisto-cluster
          wait-for-service-stability: true
      # We need to wait for the application to start we can check if it was successful. The value of 1 minute is arbitrary and can be changed
      - name: Wait for Application to start
        id: deployment-complete
        run: sleep 1m
        shell: bash

      - name: Check if deployment was successful
        id: check-deployment
        run: |
          RUNNING_TASKS=$(aws ecs describe-services --cluster web-callisto-cluster --services backend --query services[0].deployments[0].runningCount | jq -r ".")
              
          if [ "$RUNNING_TASKS" -eq "0" ]; then
            echo "Deployment failed."
            exit 1
          fi

  Deploy-Production:
    if: github.event_name == 'push' &&  github.ref == 'refs/heads/production'
    name: Deploy Callisto Production
    runs-on: ubuntu-latest
    needs: UnitTest

    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4
      - name: Load .env file
        uses: xom9ikk/dotenv@v2.2.0
        with:
          path: ./.github/workflows
          mode: variables

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: "arn:aws:iam::${{ env.PROD_ACCOUNT }}:role/github-actions-role-backend"
          role-session-name: prodrolesession
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: web-callisto-ecr-repository
          IMAGE_TAG: backend

        run: |
          docker build -f Dockerfile.api --rm --build-arg NAME=${{ env.BACKEND_NAME }} --build-arg PORT=${{ env.BACKEND_PORT }} --platform=linux/amd64 -t ${{ env.BACKEND_NAME }}:${{ env.VERSION }} . 
          docker tag ${{ env.BACKEND_NAME }}:${{ env.VERSION }} $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Task definition download
        id: download-task-def
        env:
          ecs_task_def_name: backend-task
        run: |
          aws ecs describe-task-definition --task-definition "$ecs_task_def_name" --query taskDefinition > task-definition.json

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: api
          image: ${{ steps.build-image.outputs.image }}

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        timeout-minutes: 5
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: backend
          cluster: web-callisto-cluster
          wait-for-service-stability: true
      # We need to wait for the application to start we can check if it was successful. The value of 1 minute is arbitrary and can be changed
      - name: Wait for Application to start
        id: deployment-complete
        run: sleep 1m
        shell: bash

      - name: Check if deployment was successful
        id: check-deployment
        run: |
          RUNNING_TASKS=$(aws ecs describe-services --cluster web-callisto-cluster --services backend --query services[0].deployments[0].runningCount | jq -r ".")
              
          if [ "$RUNNING_TASKS" -eq "0" ]; then
            echo "Deployment failed."
            exit 1
          fi
